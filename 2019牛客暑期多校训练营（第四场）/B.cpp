/* Generated by powerful Codeforces Tool
 * Author: calabash_boy_love_15
 * Time: 2019-05-15 11:00:02
 * Personal Code Template: https://github.com/4thcalabash/ACM-Code-Library
**/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m;
char *YES = "YES";
char *NO = "NO";
const int maxn = 50000 + 5;

struct Linear_Basis{
    //basis vector
    ll basis[40];
    bool droped = false;
    void clear(){
        memset(basis,0,sizeof basis);
    }
    void ins(ll x){
        bool drop = true;
        for (int i=31;i>=0;i--){
            if (x & (1ll<< i)){
                if (!basis[i]){basis[i] = x;drop = false;break;}
                x ^= basis[i];
            }
        }
        droped |= drop;
    }
    bool can(ll val){
        for (int i=31;i>=0;i--){
            if (val & (1ll << i)){
                if (basis[i])val ^= basis[i];
                else return false;
            }
        }
        return val == 0;
    }
    void debug(){
        cerr<<"--------"<<endl;
        for (int i=31;i>=0;i--){
            if (basis[i]){
                cerr<<basis[i]<<endl;
            }
        }
    }
    Linear_Basis (const Linear_Basis & other){
        for (int i=0;i<=31;i++)basis[i] = other.basis[i];
    }
    Linear_Basis(bool full = false){
        if (full){
            for (int i=31;i>=0;i--){
                basis[i] = 1ll << i;
            }
        }else clear();
    }
    Linear_Basis operator & (const Linear_Basis &other)const{
        Linear_Basis ret = other;
        Linear_Basis c,d;
        for (int i=31;i>=0;i--){
            d.basis[i] = 1ll << i;
        }
        for (int i=31;i>=0;i--){
            if (basis[i]){
                ll v = basis[i],k=0;
                bool can = true;
                for (int j=31;j>=0;j--){
                    if (v & (1ll << j)){
                        if (ret.basis[j]){
                            v ^= ret.basis[j];
                            k ^= d.basis[j];
                        }else{
                            can = false;
                            ret.basis[j] = v;
                            d.basis[j] = k;
                            break;
                        }
                    }
                }
                if (can){
                    ll v = 0;
                    for (int j=31;j>=0;j--){
                        if (k & (1ll << j)){
                            v ^= other.basis[j];
                        }
                    }
                    c.ins(v);
                }
            }
        }
        return c;
    }
}basis[maxn];
struct Segment_Tree{
    Linear_Basis bas[maxn*4];
    void build(int x,int l,int r){
        if (l == r){
            bas[x] = basis[l];
            return;
        }
        int mid = l + r >> 1;
        build(x<<1,l,mid);
        build(x<<1|1,mid+1,r);
        bas[x] = bas[x<<1] & bas[x<<1|1];
    }
    bool query(int x,int l,int r,int L,int R,ll val){
        if (l > R || L > r)return true;
        if (L <= l && r <= R)return bas[x].can(val);
        int mid = l + r >> 1;
        return query(x << 1,l,mid,L,R,val) & query(x<<1|1,mid+1,r,L,R,val);
    }
}tree;
int dig[40];
char * gao(int l,int r,ll val){

    if (tree.query(1,1,n,l,r,val))
        return YES;
    else return NO;
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        int num;
        scanf("%d",&num);
        while (num--){
            ll x;
            scanf("%lld",&x);
            basis[i].ins(x);
        }
    }
    tree.build(1,1,n);
    while (m--){
        int l,r;
        ll x;
        scanf("%d%d%lld",&l,&r,&x);
        puts(gao(l,r,x));
    }
    return 0;
}
